schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "Account"
"""
type Account {
  """An array relationship"""
  authoredProjects(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """An aggregate relationship"""
  authoredProjects_aggregate(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): Project_aggregate!

  """An array relationship"""
  curatedProjects(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """An aggregate relationship"""
  curatedProjects_aggregate(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): Project_aggregate!
  id: uuid!

  """An array relationship"""
  profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """An aggregate relationship"""
  profile_aggregate(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): Profile_aggregate!
  status: AccountStatus!
  username: String!

  """An array relationship"""
  wallets(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """An aggregate relationship"""
  wallets_aggregate(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): Wallet_aggregate!
}

scalar AccountStatus

"""
Boolean expression to compare columns of type "AccountStatus". All fields are combined with logical 'AND'.
"""
input AccountStatus_comparison_exp {
  _eq: AccountStatus
  _gt: AccountStatus
  _gte: AccountStatus
  _in: [AccountStatus!]
  _is_null: Boolean
  _lt: AccountStatus
  _lte: AccountStatus
  _neq: AccountStatus
  _nin: [AccountStatus!]
}

"""
aggregated selection of "Account"
"""
type Account_aggregate {
  aggregate: Account_aggregate_fields
  nodes: [Account!]!
}

"""
aggregate fields of "Account"
"""
type Account_aggregate_fields {
  count(columns: [Account_select_column!], distinct: Boolean): Int!
  max: Account_max_fields
  min: Account_min_fields
}

"""
Boolean expression to filter rows from the table "Account". All fields are combined with a logical 'AND'.
"""
input Account_bool_exp {
  _and: [Account_bool_exp!]
  _not: Account_bool_exp
  _or: [Account_bool_exp!]
  authoredProjects: Project_bool_exp
  authoredProjects_aggregate: Project_aggregate_bool_exp
  curatedProjects: Project_bool_exp
  curatedProjects_aggregate: Project_aggregate_bool_exp
  id: uuid_comparison_exp
  profile: Profile_bool_exp
  profile_aggregate: Profile_aggregate_bool_exp
  status: AccountStatus_comparison_exp
  username: String_comparison_exp
  wallets: Wallet_bool_exp
  wallets_aggregate: Wallet_aggregate_bool_exp
}

"""
unique or primary key constraints on table "Account"
"""
enum Account_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Account_pkey

  """
  unique or primary key constraint on columns "username"
  """
  Account_username_key
}

"""
input type for inserting data into table "Account"
"""
input Account_insert_input {
  authoredProjects: Project_arr_rel_insert_input
  curatedProjects: Project_arr_rel_insert_input
  id: uuid
  profile: Profile_arr_rel_insert_input
  status: AccountStatus
  username: String
  wallets: Wallet_arr_rel_insert_input
}

"""aggregate max on columns"""
type Account_max_fields {
  id: uuid
  status: AccountStatus
  username: String
}

"""aggregate min on columns"""
type Account_min_fields {
  id: uuid
  status: AccountStatus
  username: String
}

"""
response of any mutation on the table "Account"
"""
type Account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Account!]!
}

"""
input type for inserting object relation for remote table "Account"
"""
input Account_obj_rel_insert_input {
  data: Account_insert_input!

  """upsert condition"""
  on_conflict: Account_on_conflict
}

"""
on_conflict condition type for table "Account"
"""
input Account_on_conflict {
  constraint: Account_constraint!
  update_columns: [Account_update_column!]! = []
  where: Account_bool_exp
}

"""Ordering options when selecting data from "Account"."""
input Account_order_by {
  authoredProjects_aggregate: Project_aggregate_order_by
  curatedProjects_aggregate: Project_aggregate_order_by
  id: order_by
  profile_aggregate: Profile_aggregate_order_by
  status: order_by
  username: order_by
  wallets_aggregate: Wallet_aggregate_order_by
}

"""primary key columns input for table: Account"""
input Account_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Account"
"""
enum Account_select_column {
  """column name"""
  id

  """column name"""
  status

  """column name"""
  username
}

"""
input type for updating data in table "Account"
"""
input Account_set_input {
  id: uuid
  status: AccountStatus
  username: String
}

"""
Streaming cursor of the table "Account"
"""
input Account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Account_stream_cursor_value_input {
  id: uuid
  status: AccountStatus
  username: String
}

"""
update columns of table "Account"
"""
enum Account_update_column {
  """column name"""
  id

  """column name"""
  status

  """column name"""
  username
}

input Account_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Account_set_input

  """filter the rows which have to be updated"""
  where: Account_bool_exp!
}

scalar BlockchainNetwork

"""
Boolean expression to compare columns of type "BlockchainNetwork". All fields are combined with logical 'AND'.
"""
input BlockchainNetwork_comparison_exp {
  _eq: BlockchainNetwork
  _gt: BlockchainNetwork
  _gte: BlockchainNetwork
  _in: [BlockchainNetwork!]
  _is_null: Boolean
  _lt: BlockchainNetwork
  _lte: BlockchainNetwork
  _neq: BlockchainNetwork
  _nin: [BlockchainNetwork!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "Media"
"""
type Media {
  bucketId: String!
  createdAt: timestamp!
  etag: String!
  id: uuid!
  name: String!

  """An array relationship"""
  project(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """An aggregate relationship"""
  project_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): ProjectMedia_aggregate!
  s3key: String!
  size: Int!
  updatedAt: timestamp!

  """An object relationship"""
  uploader: Account
  uploaderId: uuid
  url: String!
}

"""
aggregated selection of "Media"
"""
type Media_aggregate {
  aggregate: Media_aggregate_fields
  nodes: [Media!]!
}

"""
aggregate fields of "Media"
"""
type Media_aggregate_fields {
  avg: Media_avg_fields
  count(columns: [Media_select_column!], distinct: Boolean): Int!
  max: Media_max_fields
  min: Media_min_fields
  stddev: Media_stddev_fields
  stddev_pop: Media_stddev_pop_fields
  stddev_samp: Media_stddev_samp_fields
  sum: Media_sum_fields
  var_pop: Media_var_pop_fields
  var_samp: Media_var_samp_fields
  variance: Media_variance_fields
}

"""aggregate avg on columns"""
type Media_avg_fields {
  size: Float
}

"""
Boolean expression to filter rows from the table "Media". All fields are combined with a logical 'AND'.
"""
input Media_bool_exp {
  _and: [Media_bool_exp!]
  _not: Media_bool_exp
  _or: [Media_bool_exp!]
  bucketId: String_comparison_exp
  createdAt: timestamp_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  project: ProjectMedia_bool_exp
  project_aggregate: ProjectMedia_aggregate_bool_exp
  s3key: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamp_comparison_exp
  uploader: Account_bool_exp
  uploaderId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "Media"
"""
enum Media_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Media_pkey
}

"""
input type for incrementing numeric columns in table "Media"
"""
input Media_inc_input {
  size: Int
}

"""
input type for inserting data into table "Media"
"""
input Media_insert_input {
  bucketId: String
  createdAt: timestamp
  etag: String
  id: uuid
  name: String
  project: ProjectMedia_arr_rel_insert_input
  s3key: String
  size: Int
  updatedAt: timestamp
  uploader: Account_obj_rel_insert_input
  uploaderId: uuid
}

"""aggregate max on columns"""
type Media_max_fields {
  bucketId: String
  createdAt: timestamp
  etag: String
  id: uuid
  name: String
  s3key: String
  size: Int
  updatedAt: timestamp
  uploaderId: uuid
}

"""aggregate min on columns"""
type Media_min_fields {
  bucketId: String
  createdAt: timestamp
  etag: String
  id: uuid
  name: String
  s3key: String
  size: Int
  updatedAt: timestamp
  uploaderId: uuid
}

"""
response of any mutation on the table "Media"
"""
type Media_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Media!]!
}

"""
input type for inserting object relation for remote table "Media"
"""
input Media_obj_rel_insert_input {
  data: Media_insert_input!

  """upsert condition"""
  on_conflict: Media_on_conflict
}

"""
on_conflict condition type for table "Media"
"""
input Media_on_conflict {
  constraint: Media_constraint!
  update_columns: [Media_update_column!]! = []
  where: Media_bool_exp
}

"""Ordering options when selecting data from "Media"."""
input Media_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  name: order_by
  project_aggregate: ProjectMedia_aggregate_order_by
  s3key: order_by
  size: order_by
  updatedAt: order_by
  uploader: Account_order_by
  uploaderId: order_by
}

"""primary key columns input for table: Media"""
input Media_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Media"
"""
enum Media_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  name

  """column name"""
  s3key

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploaderId
}

"""
input type for updating data in table "Media"
"""
input Media_set_input {
  bucketId: String
  createdAt: timestamp
  etag: String
  id: uuid
  name: String
  s3key: String
  size: Int
  updatedAt: timestamp
  uploaderId: uuid
}

"""aggregate stddev on columns"""
type Media_stddev_fields {
  size: Float
}

"""aggregate stddev_pop on columns"""
type Media_stddev_pop_fields {
  size: Float
}

"""aggregate stddev_samp on columns"""
type Media_stddev_samp_fields {
  size: Float
}

"""
Streaming cursor of the table "Media"
"""
input Media_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Media_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Media_stream_cursor_value_input {
  bucketId: String
  createdAt: timestamp
  etag: String
  id: uuid
  name: String
  s3key: String
  size: Int
  updatedAt: timestamp
  uploaderId: uuid
}

"""aggregate sum on columns"""
type Media_sum_fields {
  size: Int
}

"""
update columns of table "Media"
"""
enum Media_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  name

  """column name"""
  s3key

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploaderId
}

input Media_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: Media_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: Media_set_input

  """filter the rows which have to be updated"""
  where: Media_bool_exp!
}

"""aggregate var_pop on columns"""
type Media_var_pop_fields {
  size: Float
}

"""aggregate var_samp on columns"""
type Media_var_samp_fields {
  size: Float
}

"""aggregate variance on columns"""
type Media_variance_fields {
  size: Float
}

"""
columns and relationships of "Profile"
"""
type Profile {
  accountId: uuid!
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
aggregated selection of "Profile"
"""
type Profile_aggregate {
  aggregate: Profile_aggregate_fields
  nodes: [Profile!]!
}

input Profile_aggregate_bool_exp {
  count: Profile_aggregate_bool_exp_count
}

input Profile_aggregate_bool_exp_count {
  arguments: [Profile_select_column!]
  distinct: Boolean
  filter: Profile_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "Profile"
"""
type Profile_aggregate_fields {
  count(columns: [Profile_select_column!], distinct: Boolean): Int!
  max: Profile_max_fields
  min: Profile_min_fields
}

"""
order by aggregate values of table "Profile"
"""
input Profile_aggregate_order_by {
  count: order_by
  max: Profile_max_order_by
  min: Profile_min_order_by
}

"""
input type for inserting array relation for remote table "Profile"
"""
input Profile_arr_rel_insert_input {
  data: [Profile_insert_input!]!

  """upsert condition"""
  on_conflict: Profile_on_conflict
}

"""
Boolean expression to filter rows from the table "Profile". All fields are combined with a logical 'AND'.
"""
input Profile_bool_exp {
  _and: [Profile_bool_exp!]
  _not: Profile_bool_exp
  _or: [Profile_bool_exp!]
  accountId: uuid_comparison_exp
  description: String_comparison_exp
  instagram: String_comparison_exp
  picture: String_comparison_exp
  twitter: String_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "Profile"
"""
enum Profile_constraint {
  """
  unique or primary key constraint on columns "accountId"
  """
  Profile_pkey
}

"""
input type for inserting data into table "Profile"
"""
input Profile_insert_input {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""aggregate max on columns"""
type Profile_max_fields {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
order by max() on columns of table "Profile"
"""
input Profile_max_order_by {
  accountId: order_by
  description: order_by
  instagram: order_by
  picture: order_by
  twitter: order_by
  website: order_by
}

"""aggregate min on columns"""
type Profile_min_fields {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
order by min() on columns of table "Profile"
"""
input Profile_min_order_by {
  accountId: order_by
  description: order_by
  instagram: order_by
  picture: order_by
  twitter: order_by
  website: order_by
}

"""
response of any mutation on the table "Profile"
"""
type Profile_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Profile!]!
}

"""
on_conflict condition type for table "Profile"
"""
input Profile_on_conflict {
  constraint: Profile_constraint!
  update_columns: [Profile_update_column!]! = []
  where: Profile_bool_exp
}

"""Ordering options when selecting data from "Profile"."""
input Profile_order_by {
  accountId: order_by
  description: order_by
  instagram: order_by
  picture: order_by
  twitter: order_by
  website: order_by
}

"""primary key columns input for table: Profile"""
input Profile_pk_columns_input {
  accountId: uuid!
}

"""
select columns of table "Profile"
"""
enum Profile_select_column {
  """column name"""
  accountId

  """column name"""
  description

  """column name"""
  instagram

  """column name"""
  picture

  """column name"""
  twitter

  """column name"""
  website
}

"""
input type for updating data in table "Profile"
"""
input Profile_set_input {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
Streaming cursor of the table "Profile"
"""
input Profile_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Profile_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Profile_stream_cursor_value_input {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
update columns of table "Profile"
"""
enum Profile_update_column {
  """column name"""
  accountId

  """column name"""
  description

  """column name"""
  instagram

  """column name"""
  picture

  """column name"""
  twitter

  """column name"""
  website
}

input Profile_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Profile_set_input

  """filter the rows which have to be updated"""
  where: Profile_bool_exp!
}

"""
columns and relationships of "Project"
"""
type Project {
  """An object relationship"""
  author: Account!
  authorId: uuid!
  blockchain: BlockchainNetwork
  createdAt: timestamp!

  """An object relationship"""
  curator: Account
  curatorId: uuid
  description: String
  id: uuid!
  pricing(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  projectMedias(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """An aggregate relationship"""
  projectMedias_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): ProjectMedia_aggregate!
  releaseAt: timestamp
  state: ProjectState!
  storage: Storage
  title: String!
  updatedAt: timestamp!
}

"""
columns and relationships of "ProjectMedia"
"""
type ProjectMedia {
  index: smallint!

  """An object relationship"""
  media: Media!
  mediaId: uuid!

  """An object relationship"""
  project: Project!
  projectId: uuid!
}

"""
aggregated selection of "ProjectMedia"
"""
type ProjectMedia_aggregate {
  aggregate: ProjectMedia_aggregate_fields
  nodes: [ProjectMedia!]!
}

input ProjectMedia_aggregate_bool_exp {
  count: ProjectMedia_aggregate_bool_exp_count
}

input ProjectMedia_aggregate_bool_exp_count {
  arguments: [ProjectMedia_select_column!]
  distinct: Boolean
  filter: ProjectMedia_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ProjectMedia"
"""
type ProjectMedia_aggregate_fields {
  avg: ProjectMedia_avg_fields
  count(columns: [ProjectMedia_select_column!], distinct: Boolean): Int!
  max: ProjectMedia_max_fields
  min: ProjectMedia_min_fields
  stddev: ProjectMedia_stddev_fields
  stddev_pop: ProjectMedia_stddev_pop_fields
  stddev_samp: ProjectMedia_stddev_samp_fields
  sum: ProjectMedia_sum_fields
  var_pop: ProjectMedia_var_pop_fields
  var_samp: ProjectMedia_var_samp_fields
  variance: ProjectMedia_variance_fields
}

"""
order by aggregate values of table "ProjectMedia"
"""
input ProjectMedia_aggregate_order_by {
  avg: ProjectMedia_avg_order_by
  count: order_by
  max: ProjectMedia_max_order_by
  min: ProjectMedia_min_order_by
  stddev: ProjectMedia_stddev_order_by
  stddev_pop: ProjectMedia_stddev_pop_order_by
  stddev_samp: ProjectMedia_stddev_samp_order_by
  sum: ProjectMedia_sum_order_by
  var_pop: ProjectMedia_var_pop_order_by
  var_samp: ProjectMedia_var_samp_order_by
  variance: ProjectMedia_variance_order_by
}

"""
input type for inserting array relation for remote table "ProjectMedia"
"""
input ProjectMedia_arr_rel_insert_input {
  data: [ProjectMedia_insert_input!]!

  """upsert condition"""
  on_conflict: ProjectMedia_on_conflict
}

"""aggregate avg on columns"""
type ProjectMedia_avg_fields {
  index: Float
}

"""
order by avg() on columns of table "ProjectMedia"
"""
input ProjectMedia_avg_order_by {
  index: order_by
}

"""
Boolean expression to filter rows from the table "ProjectMedia". All fields are combined with a logical 'AND'.
"""
input ProjectMedia_bool_exp {
  _and: [ProjectMedia_bool_exp!]
  _not: ProjectMedia_bool_exp
  _or: [ProjectMedia_bool_exp!]
  index: smallint_comparison_exp
  media: Media_bool_exp
  mediaId: uuid_comparison_exp
  project: Project_bool_exp
  projectId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "ProjectMedia"
"""
enum ProjectMedia_constraint {
  """
  unique or primary key constraint on columns "index", "mediaId", "projectId"
  """
  ProjectMedia_index_projectId_mediaId_key
}

"""
input type for incrementing numeric columns in table "ProjectMedia"
"""
input ProjectMedia_inc_input {
  index: smallint
}

"""
input type for inserting data into table "ProjectMedia"
"""
input ProjectMedia_insert_input {
  index: smallint
  media: Media_obj_rel_insert_input
  mediaId: uuid
  project: Project_obj_rel_insert_input
  projectId: uuid
}

"""aggregate max on columns"""
type ProjectMedia_max_fields {
  index: smallint
  mediaId: uuid
  projectId: uuid
}

"""
order by max() on columns of table "ProjectMedia"
"""
input ProjectMedia_max_order_by {
  index: order_by
  mediaId: order_by
  projectId: order_by
}

"""aggregate min on columns"""
type ProjectMedia_min_fields {
  index: smallint
  mediaId: uuid
  projectId: uuid
}

"""
order by min() on columns of table "ProjectMedia"
"""
input ProjectMedia_min_order_by {
  index: order_by
  mediaId: order_by
  projectId: order_by
}

"""
response of any mutation on the table "ProjectMedia"
"""
type ProjectMedia_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProjectMedia!]!
}

"""
on_conflict condition type for table "ProjectMedia"
"""
input ProjectMedia_on_conflict {
  constraint: ProjectMedia_constraint!
  update_columns: [ProjectMedia_update_column!]! = []
  where: ProjectMedia_bool_exp
}

"""Ordering options when selecting data from "ProjectMedia"."""
input ProjectMedia_order_by {
  index: order_by
  media: Media_order_by
  mediaId: order_by
  project: Project_order_by
  projectId: order_by
}

"""
select columns of table "ProjectMedia"
"""
enum ProjectMedia_select_column {
  """column name"""
  index

  """column name"""
  mediaId

  """column name"""
  projectId
}

"""
input type for updating data in table "ProjectMedia"
"""
input ProjectMedia_set_input {
  index: smallint
  mediaId: uuid
  projectId: uuid
}

"""aggregate stddev on columns"""
type ProjectMedia_stddev_fields {
  index: Float
}

"""
order by stddev() on columns of table "ProjectMedia"
"""
input ProjectMedia_stddev_order_by {
  index: order_by
}

"""aggregate stddev_pop on columns"""
type ProjectMedia_stddev_pop_fields {
  index: Float
}

"""
order by stddev_pop() on columns of table "ProjectMedia"
"""
input ProjectMedia_stddev_pop_order_by {
  index: order_by
}

"""aggregate stddev_samp on columns"""
type ProjectMedia_stddev_samp_fields {
  index: Float
}

"""
order by stddev_samp() on columns of table "ProjectMedia"
"""
input ProjectMedia_stddev_samp_order_by {
  index: order_by
}

"""
Streaming cursor of the table "ProjectMedia"
"""
input ProjectMedia_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ProjectMedia_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ProjectMedia_stream_cursor_value_input {
  index: smallint
  mediaId: uuid
  projectId: uuid
}

"""aggregate sum on columns"""
type ProjectMedia_sum_fields {
  index: smallint
}

"""
order by sum() on columns of table "ProjectMedia"
"""
input ProjectMedia_sum_order_by {
  index: order_by
}

"""
update columns of table "ProjectMedia"
"""
enum ProjectMedia_update_column {
  """column name"""
  index

  """column name"""
  mediaId

  """column name"""
  projectId
}

input ProjectMedia_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ProjectMedia_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ProjectMedia_set_input

  """filter the rows which have to be updated"""
  where: ProjectMedia_bool_exp!
}

"""aggregate var_pop on columns"""
type ProjectMedia_var_pop_fields {
  index: Float
}

"""
order by var_pop() on columns of table "ProjectMedia"
"""
input ProjectMedia_var_pop_order_by {
  index: order_by
}

"""aggregate var_samp on columns"""
type ProjectMedia_var_samp_fields {
  index: Float
}

"""
order by var_samp() on columns of table "ProjectMedia"
"""
input ProjectMedia_var_samp_order_by {
  index: order_by
}

"""aggregate variance on columns"""
type ProjectMedia_variance_fields {
  index: Float
}

"""
order by variance() on columns of table "ProjectMedia"
"""
input ProjectMedia_variance_order_by {
  index: order_by
}

scalar ProjectState

"""
Boolean expression to compare columns of type "ProjectState". All fields are combined with logical 'AND'.
"""
input ProjectState_comparison_exp {
  _eq: ProjectState
  _gt: ProjectState
  _gte: ProjectState
  _in: [ProjectState!]
  _is_null: Boolean
  _lt: ProjectState
  _lte: ProjectState
  _neq: ProjectState
  _nin: [ProjectState!]
}

"""
aggregated selection of "Project"
"""
type Project_aggregate {
  aggregate: Project_aggregate_fields
  nodes: [Project!]!
}

input Project_aggregate_bool_exp {
  count: Project_aggregate_bool_exp_count
}

input Project_aggregate_bool_exp_count {
  arguments: [Project_select_column!]
  distinct: Boolean
  filter: Project_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "Project"
"""
type Project_aggregate_fields {
  count(columns: [Project_select_column!], distinct: Boolean): Int!
  max: Project_max_fields
  min: Project_min_fields
}

"""
order by aggregate values of table "Project"
"""
input Project_aggregate_order_by {
  count: order_by
  max: Project_max_order_by
  min: Project_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Project_append_input {
  pricing: jsonb
}

"""
input type for inserting array relation for remote table "Project"
"""
input Project_arr_rel_insert_input {
  data: [Project_insert_input!]!

  """upsert condition"""
  on_conflict: Project_on_conflict
}

"""
Boolean expression to filter rows from the table "Project". All fields are combined with a logical 'AND'.
"""
input Project_bool_exp {
  _and: [Project_bool_exp!]
  _not: Project_bool_exp
  _or: [Project_bool_exp!]
  author: Account_bool_exp
  authorId: uuid_comparison_exp
  blockchain: BlockchainNetwork_comparison_exp
  createdAt: timestamp_comparison_exp
  curator: Account_bool_exp
  curatorId: uuid_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  pricing: jsonb_comparison_exp
  projectMedias: ProjectMedia_bool_exp
  projectMedias_aggregate: ProjectMedia_aggregate_bool_exp
  releaseAt: timestamp_comparison_exp
  state: ProjectState_comparison_exp
  storage: Storage_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "Project"
"""
enum Project_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Project_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Project_delete_at_path_input {
  pricing: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input Project_delete_elem_input {
  pricing: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Project_delete_key_input {
  pricing: String
}

"""
input type for inserting data into table "Project"
"""
input Project_insert_input {
  author: Account_obj_rel_insert_input
  authorId: uuid
  blockchain: BlockchainNetwork
  createdAt: timestamp
  curator: Account_obj_rel_insert_input
  curatorId: uuid
  description: String
  id: uuid
  pricing: jsonb
  projectMedias: ProjectMedia_arr_rel_insert_input
  releaseAt: timestamp
  state: ProjectState
  storage: Storage
  title: String
  updatedAt: timestamp
}

"""aggregate max on columns"""
type Project_max_fields {
  authorId: uuid
  blockchain: BlockchainNetwork
  createdAt: timestamp
  curatorId: uuid
  description: String
  id: uuid
  releaseAt: timestamp
  state: ProjectState
  storage: Storage
  title: String
  updatedAt: timestamp
}

"""
order by max() on columns of table "Project"
"""
input Project_max_order_by {
  authorId: order_by
  blockchain: order_by
  createdAt: order_by
  curatorId: order_by
  description: order_by
  id: order_by
  releaseAt: order_by
  state: order_by
  storage: order_by
  title: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type Project_min_fields {
  authorId: uuid
  blockchain: BlockchainNetwork
  createdAt: timestamp
  curatorId: uuid
  description: String
  id: uuid
  releaseAt: timestamp
  state: ProjectState
  storage: Storage
  title: String
  updatedAt: timestamp
}

"""
order by min() on columns of table "Project"
"""
input Project_min_order_by {
  authorId: order_by
  blockchain: order_by
  createdAt: order_by
  curatorId: order_by
  description: order_by
  id: order_by
  releaseAt: order_by
  state: order_by
  storage: order_by
  title: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "Project"
"""
type Project_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Project!]!
}

"""
input type for inserting object relation for remote table "Project"
"""
input Project_obj_rel_insert_input {
  data: Project_insert_input!

  """upsert condition"""
  on_conflict: Project_on_conflict
}

"""
on_conflict condition type for table "Project"
"""
input Project_on_conflict {
  constraint: Project_constraint!
  update_columns: [Project_update_column!]! = []
  where: Project_bool_exp
}

"""Ordering options when selecting data from "Project"."""
input Project_order_by {
  author: Account_order_by
  authorId: order_by
  blockchain: order_by
  createdAt: order_by
  curator: Account_order_by
  curatorId: order_by
  description: order_by
  id: order_by
  pricing: order_by
  projectMedias_aggregate: ProjectMedia_aggregate_order_by
  releaseAt: order_by
  state: order_by
  storage: order_by
  title: order_by
  updatedAt: order_by
}

"""primary key columns input for table: Project"""
input Project_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Project_prepend_input {
  pricing: jsonb
}

"""
select columns of table "Project"
"""
enum Project_select_column {
  """column name"""
  authorId

  """column name"""
  blockchain

  """column name"""
  createdAt

  """column name"""
  curatorId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  pricing

  """column name"""
  releaseAt

  """column name"""
  state

  """column name"""
  storage

  """column name"""
  title

  """column name"""
  updatedAt
}

"""
input type for updating data in table "Project"
"""
input Project_set_input {
  authorId: uuid
  blockchain: BlockchainNetwork
  createdAt: timestamp
  curatorId: uuid
  description: String
  id: uuid
  pricing: jsonb
  releaseAt: timestamp
  state: ProjectState
  storage: Storage
  title: String
  updatedAt: timestamp
}

"""
Streaming cursor of the table "Project"
"""
input Project_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Project_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Project_stream_cursor_value_input {
  authorId: uuid
  blockchain: BlockchainNetwork
  createdAt: timestamp
  curatorId: uuid
  description: String
  id: uuid
  pricing: jsonb
  releaseAt: timestamp
  state: ProjectState
  storage: Storage
  title: String
  updatedAt: timestamp
}

"""
update columns of table "Project"
"""
enum Project_update_column {
  """column name"""
  authorId

  """column name"""
  blockchain

  """column name"""
  createdAt

  """column name"""
  curatorId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  pricing

  """column name"""
  releaseAt

  """column name"""
  state

  """column name"""
  storage

  """column name"""
  title

  """column name"""
  updatedAt
}

input Project_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: Project_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: Project_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: Project_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: Project_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: Project_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: Project_set_input

  """filter the rows which have to be updated"""
  where: Project_bool_exp!
}

scalar Storage

"""
Boolean expression to compare columns of type "Storage". All fields are combined with logical 'AND'.
"""
input Storage_comparison_exp {
  _eq: Storage
  _gt: Storage
  _gte: Storage
  _in: [Storage!]
  _is_null: Boolean
  _lt: Storage
  _lte: Storage
  _neq: Storage
  _nin: [Storage!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "Wallet"
"""
type Wallet {
  accountId: uuid!
  address: String!
  network: BlockchainNetwork!
}

"""
aggregated selection of "Wallet"
"""
type Wallet_aggregate {
  aggregate: Wallet_aggregate_fields
  nodes: [Wallet!]!
}

input Wallet_aggregate_bool_exp {
  count: Wallet_aggregate_bool_exp_count
}

input Wallet_aggregate_bool_exp_count {
  arguments: [Wallet_select_column!]
  distinct: Boolean
  filter: Wallet_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "Wallet"
"""
type Wallet_aggregate_fields {
  count(columns: [Wallet_select_column!], distinct: Boolean): Int!
  max: Wallet_max_fields
  min: Wallet_min_fields
}

"""
order by aggregate values of table "Wallet"
"""
input Wallet_aggregate_order_by {
  count: order_by
  max: Wallet_max_order_by
  min: Wallet_min_order_by
}

"""
input type for inserting array relation for remote table "Wallet"
"""
input Wallet_arr_rel_insert_input {
  data: [Wallet_insert_input!]!

  """upsert condition"""
  on_conflict: Wallet_on_conflict
}

"""
Boolean expression to filter rows from the table "Wallet". All fields are combined with a logical 'AND'.
"""
input Wallet_bool_exp {
  _and: [Wallet_bool_exp!]
  _not: Wallet_bool_exp
  _or: [Wallet_bool_exp!]
  accountId: uuid_comparison_exp
  address: String_comparison_exp
  network: BlockchainNetwork_comparison_exp
}

"""
unique or primary key constraints on table "Wallet"
"""
enum Wallet_constraint {
  """
  unique or primary key constraint on columns "address"
  """
  Wallet_pkey
}

"""
input type for inserting data into table "Wallet"
"""
input Wallet_insert_input {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""aggregate max on columns"""
type Wallet_max_fields {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
order by max() on columns of table "Wallet"
"""
input Wallet_max_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""aggregate min on columns"""
type Wallet_min_fields {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
order by min() on columns of table "Wallet"
"""
input Wallet_min_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""
response of any mutation on the table "Wallet"
"""
type Wallet_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Wallet!]!
}

"""
on_conflict condition type for table "Wallet"
"""
input Wallet_on_conflict {
  constraint: Wallet_constraint!
  update_columns: [Wallet_update_column!]! = []
  where: Wallet_bool_exp
}

"""Ordering options when selecting data from "Wallet"."""
input Wallet_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""primary key columns input for table: Wallet"""
input Wallet_pk_columns_input {
  address: String!
}

"""
select columns of table "Wallet"
"""
enum Wallet_select_column {
  """column name"""
  accountId

  """column name"""
  address

  """column name"""
  network
}

"""
input type for updating data in table "Wallet"
"""
input Wallet_set_input {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
Streaming cursor of the table "Wallet"
"""
input Wallet_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Wallet_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Wallet_stream_cursor_value_input {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
update columns of table "Wallet"
"""
enum Wallet_update_column {
  """column name"""
  accountId

  """column name"""
  address

  """column name"""
  network
}

input Wallet_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Wallet_set_input

  """filter the rows which have to be updated"""
  where: Wallet_bool_exp!
}

"""
columns and relationships of "_prisma_migrations"
"""
type _prisma_migrations {
  applied_steps_count: Int!
  checksum: String!
  finished_at: timestamptz
  id: String!
  logs: String
  migration_name: String!
  rolled_back_at: timestamptz
  started_at: timestamptz!
}

"""
aggregated selection of "_prisma_migrations"
"""
type _prisma_migrations_aggregate {
  aggregate: _prisma_migrations_aggregate_fields
  nodes: [_prisma_migrations!]!
}

"""
aggregate fields of "_prisma_migrations"
"""
type _prisma_migrations_aggregate_fields {
  avg: _prisma_migrations_avg_fields
  count(columns: [_prisma_migrations_select_column!], distinct: Boolean): Int!
  max: _prisma_migrations_max_fields
  min: _prisma_migrations_min_fields
  stddev: _prisma_migrations_stddev_fields
  stddev_pop: _prisma_migrations_stddev_pop_fields
  stddev_samp: _prisma_migrations_stddev_samp_fields
  sum: _prisma_migrations_sum_fields
  var_pop: _prisma_migrations_var_pop_fields
  var_samp: _prisma_migrations_var_samp_fields
  variance: _prisma_migrations_variance_fields
}

"""aggregate avg on columns"""
type _prisma_migrations_avg_fields {
  applied_steps_count: Float
}

"""
Boolean expression to filter rows from the table "_prisma_migrations". All fields are combined with a logical 'AND'.
"""
input _prisma_migrations_bool_exp {
  _and: [_prisma_migrations_bool_exp!]
  _not: _prisma_migrations_bool_exp
  _or: [_prisma_migrations_bool_exp!]
  applied_steps_count: Int_comparison_exp
  checksum: String_comparison_exp
  finished_at: timestamptz_comparison_exp
  id: String_comparison_exp
  logs: String_comparison_exp
  migration_name: String_comparison_exp
  rolled_back_at: timestamptz_comparison_exp
  started_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "_prisma_migrations"
"""
enum _prisma_migrations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  _prisma_migrations_pkey
}

"""
input type for incrementing numeric columns in table "_prisma_migrations"
"""
input _prisma_migrations_inc_input {
  applied_steps_count: Int
}

"""
input type for inserting data into table "_prisma_migrations"
"""
input _prisma_migrations_insert_input {
  applied_steps_count: Int
  checksum: String
  finished_at: timestamptz
  id: String
  logs: String
  migration_name: String
  rolled_back_at: timestamptz
  started_at: timestamptz
}

"""aggregate max on columns"""
type _prisma_migrations_max_fields {
  applied_steps_count: Int
  checksum: String
  finished_at: timestamptz
  id: String
  logs: String
  migration_name: String
  rolled_back_at: timestamptz
  started_at: timestamptz
}

"""aggregate min on columns"""
type _prisma_migrations_min_fields {
  applied_steps_count: Int
  checksum: String
  finished_at: timestamptz
  id: String
  logs: String
  migration_name: String
  rolled_back_at: timestamptz
  started_at: timestamptz
}

"""
response of any mutation on the table "_prisma_migrations"
"""
type _prisma_migrations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [_prisma_migrations!]!
}

"""
on_conflict condition type for table "_prisma_migrations"
"""
input _prisma_migrations_on_conflict {
  constraint: _prisma_migrations_constraint!
  update_columns: [_prisma_migrations_update_column!]! = []
  where: _prisma_migrations_bool_exp
}

"""Ordering options when selecting data from "_prisma_migrations"."""
input _prisma_migrations_order_by {
  applied_steps_count: order_by
  checksum: order_by
  finished_at: order_by
  id: order_by
  logs: order_by
  migration_name: order_by
  rolled_back_at: order_by
  started_at: order_by
}

"""primary key columns input for table: _prisma_migrations"""
input _prisma_migrations_pk_columns_input {
  id: String!
}

"""
select columns of table "_prisma_migrations"
"""
enum _prisma_migrations_select_column {
  """column name"""
  applied_steps_count

  """column name"""
  checksum

  """column name"""
  finished_at

  """column name"""
  id

  """column name"""
  logs

  """column name"""
  migration_name

  """column name"""
  rolled_back_at

  """column name"""
  started_at
}

"""
input type for updating data in table "_prisma_migrations"
"""
input _prisma_migrations_set_input {
  applied_steps_count: Int
  checksum: String
  finished_at: timestamptz
  id: String
  logs: String
  migration_name: String
  rolled_back_at: timestamptz
  started_at: timestamptz
}

"""aggregate stddev on columns"""
type _prisma_migrations_stddev_fields {
  applied_steps_count: Float
}

"""aggregate stddev_pop on columns"""
type _prisma_migrations_stddev_pop_fields {
  applied_steps_count: Float
}

"""aggregate stddev_samp on columns"""
type _prisma_migrations_stddev_samp_fields {
  applied_steps_count: Float
}

"""
Streaming cursor of the table "_prisma_migrations"
"""
input _prisma_migrations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: _prisma_migrations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input _prisma_migrations_stream_cursor_value_input {
  applied_steps_count: Int
  checksum: String
  finished_at: timestamptz
  id: String
  logs: String
  migration_name: String
  rolled_back_at: timestamptz
  started_at: timestamptz
}

"""aggregate sum on columns"""
type _prisma_migrations_sum_fields {
  applied_steps_count: Int
}

"""
update columns of table "_prisma_migrations"
"""
enum _prisma_migrations_update_column {
  """column name"""
  applied_steps_count

  """column name"""
  checksum

  """column name"""
  finished_at

  """column name"""
  id

  """column name"""
  logs

  """column name"""
  migration_name

  """column name"""
  rolled_back_at

  """column name"""
  started_at
}

input _prisma_migrations_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: _prisma_migrations_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: _prisma_migrations_set_input

  """filter the rows which have to be updated"""
  where: _prisma_migrations_bool_exp!
}

"""aggregate var_pop on columns"""
type _prisma_migrations_var_pop_fields {
  applied_steps_count: Float
}

"""aggregate var_samp on columns"""
type _prisma_migrations_var_samp_fields {
  applied_steps_count: Float
}

"""aggregate variance on columns"""
type _prisma_migrations_variance_fields {
  applied_steps_count: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "Account"
  """
  delete_Account(
    """filter the rows which have to be deleted"""
    where: Account_bool_exp!
  ): Account_mutation_response

  """
  delete single row from the table: "Account"
  """
  delete_Account_by_pk(id: uuid!): Account

  """
  delete data from the table: "Media"
  """
  delete_Media(
    """filter the rows which have to be deleted"""
    where: Media_bool_exp!
  ): Media_mutation_response

  """
  delete single row from the table: "Media"
  """
  delete_Media_by_pk(id: uuid!): Media

  """
  delete data from the table: "Profile"
  """
  delete_Profile(
    """filter the rows which have to be deleted"""
    where: Profile_bool_exp!
  ): Profile_mutation_response

  """
  delete single row from the table: "Profile"
  """
  delete_Profile_by_pk(accountId: uuid!): Profile

  """
  delete data from the table: "Project"
  """
  delete_Project(
    """filter the rows which have to be deleted"""
    where: Project_bool_exp!
  ): Project_mutation_response

  """
  delete data from the table: "ProjectMedia"
  """
  delete_ProjectMedia(
    """filter the rows which have to be deleted"""
    where: ProjectMedia_bool_exp!
  ): ProjectMedia_mutation_response

  """
  delete single row from the table: "Project"
  """
  delete_Project_by_pk(id: uuid!): Project

  """
  delete data from the table: "Wallet"
  """
  delete_Wallet(
    """filter the rows which have to be deleted"""
    where: Wallet_bool_exp!
  ): Wallet_mutation_response

  """
  delete single row from the table: "Wallet"
  """
  delete_Wallet_by_pk(address: String!): Wallet

  """
  delete data from the table: "_prisma_migrations"
  """
  delete__prisma_migrations(
    """filter the rows which have to be deleted"""
    where: _prisma_migrations_bool_exp!
  ): _prisma_migrations_mutation_response

  """
  delete single row from the table: "_prisma_migrations"
  """
  delete__prisma_migrations_by_pk(id: String!): _prisma_migrations

  """
  insert data into the table: "Account"
  """
  insert_Account(
    """the rows to be inserted"""
    objects: [Account_insert_input!]!

    """upsert condition"""
    on_conflict: Account_on_conflict
  ): Account_mutation_response

  """
  insert a single row into the table: "Account"
  """
  insert_Account_one(
    """the row to be inserted"""
    object: Account_insert_input!

    """upsert condition"""
    on_conflict: Account_on_conflict
  ): Account

  """
  insert data into the table: "Media"
  """
  insert_Media(
    """the rows to be inserted"""
    objects: [Media_insert_input!]!

    """upsert condition"""
    on_conflict: Media_on_conflict
  ): Media_mutation_response

  """
  insert a single row into the table: "Media"
  """
  insert_Media_one(
    """the row to be inserted"""
    object: Media_insert_input!

    """upsert condition"""
    on_conflict: Media_on_conflict
  ): Media

  """
  insert data into the table: "Profile"
  """
  insert_Profile(
    """the rows to be inserted"""
    objects: [Profile_insert_input!]!

    """upsert condition"""
    on_conflict: Profile_on_conflict
  ): Profile_mutation_response

  """
  insert a single row into the table: "Profile"
  """
  insert_Profile_one(
    """the row to be inserted"""
    object: Profile_insert_input!

    """upsert condition"""
    on_conflict: Profile_on_conflict
  ): Profile

  """
  insert data into the table: "Project"
  """
  insert_Project(
    """the rows to be inserted"""
    objects: [Project_insert_input!]!

    """upsert condition"""
    on_conflict: Project_on_conflict
  ): Project_mutation_response

  """
  insert data into the table: "ProjectMedia"
  """
  insert_ProjectMedia(
    """the rows to be inserted"""
    objects: [ProjectMedia_insert_input!]!

    """upsert condition"""
    on_conflict: ProjectMedia_on_conflict
  ): ProjectMedia_mutation_response

  """
  insert a single row into the table: "ProjectMedia"
  """
  insert_ProjectMedia_one(
    """the row to be inserted"""
    object: ProjectMedia_insert_input!

    """upsert condition"""
    on_conflict: ProjectMedia_on_conflict
  ): ProjectMedia

  """
  insert a single row into the table: "Project"
  """
  insert_Project_one(
    """the row to be inserted"""
    object: Project_insert_input!

    """upsert condition"""
    on_conflict: Project_on_conflict
  ): Project

  """
  insert data into the table: "Wallet"
  """
  insert_Wallet(
    """the rows to be inserted"""
    objects: [Wallet_insert_input!]!

    """upsert condition"""
    on_conflict: Wallet_on_conflict
  ): Wallet_mutation_response

  """
  insert a single row into the table: "Wallet"
  """
  insert_Wallet_one(
    """the row to be inserted"""
    object: Wallet_insert_input!

    """upsert condition"""
    on_conflict: Wallet_on_conflict
  ): Wallet

  """
  insert data into the table: "_prisma_migrations"
  """
  insert__prisma_migrations(
    """the rows to be inserted"""
    objects: [_prisma_migrations_insert_input!]!

    """upsert condition"""
    on_conflict: _prisma_migrations_on_conflict
  ): _prisma_migrations_mutation_response

  """
  insert a single row into the table: "_prisma_migrations"
  """
  insert__prisma_migrations_one(
    """the row to be inserted"""
    object: _prisma_migrations_insert_input!

    """upsert condition"""
    on_conflict: _prisma_migrations_on_conflict
  ): _prisma_migrations

  """
  update data of the table: "Account"
  """
  update_Account(
    """sets the columns of the filtered rows to the given values"""
    _set: Account_set_input

    """filter the rows which have to be updated"""
    where: Account_bool_exp!
  ): Account_mutation_response

  """
  update single row of the table: "Account"
  """
  update_Account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Account_set_input
    pk_columns: Account_pk_columns_input!
  ): Account

  """
  update multiples rows of table: "Account"
  """
  update_Account_many(
    """updates to execute, in order"""
    updates: [Account_updates!]!
  ): [Account_mutation_response]

  """
  update data of the table: "Media"
  """
  update_Media(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Media_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Media_set_input

    """filter the rows which have to be updated"""
    where: Media_bool_exp!
  ): Media_mutation_response

  """
  update single row of the table: "Media"
  """
  update_Media_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: Media_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: Media_set_input
    pk_columns: Media_pk_columns_input!
  ): Media

  """
  update multiples rows of table: "Media"
  """
  update_Media_many(
    """updates to execute, in order"""
    updates: [Media_updates!]!
  ): [Media_mutation_response]

  """
  update data of the table: "Profile"
  """
  update_Profile(
    """sets the columns of the filtered rows to the given values"""
    _set: Profile_set_input

    """filter the rows which have to be updated"""
    where: Profile_bool_exp!
  ): Profile_mutation_response

  """
  update single row of the table: "Profile"
  """
  update_Profile_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Profile_set_input
    pk_columns: Profile_pk_columns_input!
  ): Profile

  """
  update multiples rows of table: "Profile"
  """
  update_Profile_many(
    """updates to execute, in order"""
    updates: [Profile_updates!]!
  ): [Profile_mutation_response]

  """
  update data of the table: "Project"
  """
  update_Project(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Project_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Project_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: Project_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Project_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Project_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Project_set_input

    """filter the rows which have to be updated"""
    where: Project_bool_exp!
  ): Project_mutation_response

  """
  update data of the table: "ProjectMedia"
  """
  update_ProjectMedia(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProjectMedia_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ProjectMedia_set_input

    """filter the rows which have to be updated"""
    where: ProjectMedia_bool_exp!
  ): ProjectMedia_mutation_response

  """
  update multiples rows of table: "ProjectMedia"
  """
  update_ProjectMedia_many(
    """updates to execute, in order"""
    updates: [ProjectMedia_updates!]!
  ): [ProjectMedia_mutation_response]

  """
  update single row of the table: "Project"
  """
  update_Project_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Project_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Project_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: Project_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Project_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Project_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Project_set_input
    pk_columns: Project_pk_columns_input!
  ): Project

  """
  update multiples rows of table: "Project"
  """
  update_Project_many(
    """updates to execute, in order"""
    updates: [Project_updates!]!
  ): [Project_mutation_response]

  """
  update data of the table: "Wallet"
  """
  update_Wallet(
    """sets the columns of the filtered rows to the given values"""
    _set: Wallet_set_input

    """filter the rows which have to be updated"""
    where: Wallet_bool_exp!
  ): Wallet_mutation_response

  """
  update single row of the table: "Wallet"
  """
  update_Wallet_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Wallet_set_input
    pk_columns: Wallet_pk_columns_input!
  ): Wallet

  """
  update multiples rows of table: "Wallet"
  """
  update_Wallet_many(
    """updates to execute, in order"""
    updates: [Wallet_updates!]!
  ): [Wallet_mutation_response]

  """
  update data of the table: "_prisma_migrations"
  """
  update__prisma_migrations(
    """increments the numeric columns with given value of the filtered values"""
    _inc: _prisma_migrations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: _prisma_migrations_set_input

    """filter the rows which have to be updated"""
    where: _prisma_migrations_bool_exp!
  ): _prisma_migrations_mutation_response

  """
  update single row of the table: "_prisma_migrations"
  """
  update__prisma_migrations_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: _prisma_migrations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: _prisma_migrations_set_input
    pk_columns: _prisma_migrations_pk_columns_input!
  ): _prisma_migrations

  """
  update multiples rows of table: "_prisma_migrations"
  """
  update__prisma_migrations_many(
    """updates to execute, in order"""
    updates: [_prisma_migrations_updates!]!
  ): [_prisma_migrations_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "Account"
  """
  Account_aggregate(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): Account_aggregate!

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: uuid!): Account

  """
  fetch data from the table: "Media"
  """
  Media(
    """distinct select on columns"""
    distinct_on: [Media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Media_order_by!]

    """filter the rows returned"""
    where: Media_bool_exp
  ): [Media!]!

  """
  fetch aggregated fields from the table: "Media"
  """
  Media_aggregate(
    """distinct select on columns"""
    distinct_on: [Media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Media_order_by!]

    """filter the rows returned"""
    where: Media_bool_exp
  ): Media_aggregate!

  """fetch data from the table: "Media" using primary key columns"""
  Media_by_pk(id: uuid!): Media

  """
  fetch data from the table: "Profile"
  """
  Profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """
  fetch aggregated fields from the table: "Profile"
  """
  Profile_aggregate(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): Profile_aggregate!

  """fetch data from the table: "Profile" using primary key columns"""
  Profile_by_pk(accountId: uuid!): Profile

  """
  fetch data from the table: "Project"
  """
  Project(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """
  fetch data from the table: "ProjectMedia"
  """
  ProjectMedia(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """
  fetch aggregated fields from the table: "ProjectMedia"
  """
  ProjectMedia_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): ProjectMedia_aggregate!

  """
  fetch aggregated fields from the table: "Project"
  """
  Project_aggregate(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): Project_aggregate!

  """fetch data from the table: "Project" using primary key columns"""
  Project_by_pk(id: uuid!): Project

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch aggregated fields from the table: "Wallet"
  """
  Wallet_aggregate(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): Wallet_aggregate!

  """fetch data from the table: "Wallet" using primary key columns"""
  Wallet_by_pk(address: String!): Wallet

  """
  fetch data from the table: "_prisma_migrations"
  """
  _prisma_migrations(
    """distinct select on columns"""
    distinct_on: [_prisma_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_prisma_migrations_order_by!]

    """filter the rows returned"""
    where: _prisma_migrations_bool_exp
  ): [_prisma_migrations!]!

  """
  fetch aggregated fields from the table: "_prisma_migrations"
  """
  _prisma_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [_prisma_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_prisma_migrations_order_by!]

    """filter the rows returned"""
    where: _prisma_migrations_bool_exp
  ): _prisma_migrations_aggregate!

  """
  fetch data from the table: "_prisma_migrations" using primary key columns
  """
  _prisma_migrations_by_pk(id: String!): _prisma_migrations
  mediaFullUrl(s3key: String!): String!
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

type subscription_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "Account"
  """
  Account_aggregate(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): Account_aggregate!

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: uuid!): Account

  """
  fetch data from the table in a streaming manner: "Account"
  """
  Account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Account_stream_cursor_input]!

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch data from the table: "Media"
  """
  Media(
    """distinct select on columns"""
    distinct_on: [Media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Media_order_by!]

    """filter the rows returned"""
    where: Media_bool_exp
  ): [Media!]!

  """
  fetch aggregated fields from the table: "Media"
  """
  Media_aggregate(
    """distinct select on columns"""
    distinct_on: [Media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Media_order_by!]

    """filter the rows returned"""
    where: Media_bool_exp
  ): Media_aggregate!

  """fetch data from the table: "Media" using primary key columns"""
  Media_by_pk(id: uuid!): Media

  """
  fetch data from the table in a streaming manner: "Media"
  """
  Media_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Media_stream_cursor_input]!

    """filter the rows returned"""
    where: Media_bool_exp
  ): [Media!]!

  """
  fetch data from the table: "Profile"
  """
  Profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """
  fetch aggregated fields from the table: "Profile"
  """
  Profile_aggregate(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): Profile_aggregate!

  """fetch data from the table: "Profile" using primary key columns"""
  Profile_by_pk(accountId: uuid!): Profile

  """
  fetch data from the table in a streaming manner: "Profile"
  """
  Profile_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Profile_stream_cursor_input]!

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """
  fetch data from the table: "Project"
  """
  Project(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """
  fetch data from the table: "ProjectMedia"
  """
  ProjectMedia(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """
  fetch aggregated fields from the table: "ProjectMedia"
  """
  ProjectMedia_aggregate(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): ProjectMedia_aggregate!

  """
  fetch data from the table in a streaming manner: "ProjectMedia"
  """
  ProjectMedia_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProjectMedia_stream_cursor_input]!

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """
  fetch aggregated fields from the table: "Project"
  """
  Project_aggregate(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): Project_aggregate!

  """fetch data from the table: "Project" using primary key columns"""
  Project_by_pk(id: uuid!): Project

  """
  fetch data from the table in a streaming manner: "Project"
  """
  Project_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Project_stream_cursor_input]!

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch aggregated fields from the table: "Wallet"
  """
  Wallet_aggregate(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): Wallet_aggregate!

  """fetch data from the table: "Wallet" using primary key columns"""
  Wallet_by_pk(address: String!): Wallet

  """
  fetch data from the table in a streaming manner: "Wallet"
  """
  Wallet_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Wallet_stream_cursor_input]!

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch data from the table: "_prisma_migrations"
  """
  _prisma_migrations(
    """distinct select on columns"""
    distinct_on: [_prisma_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_prisma_migrations_order_by!]

    """filter the rows returned"""
    where: _prisma_migrations_bool_exp
  ): [_prisma_migrations!]!

  """
  fetch aggregated fields from the table: "_prisma_migrations"
  """
  _prisma_migrations_aggregate(
    """distinct select on columns"""
    distinct_on: [_prisma_migrations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_prisma_migrations_order_by!]

    """filter the rows returned"""
    where: _prisma_migrations_bool_exp
  ): _prisma_migrations_aggregate!

  """
  fetch data from the table: "_prisma_migrations" using primary key columns
  """
  _prisma_migrations_by_pk(id: String!): _prisma_migrations

  """
  fetch data from the table in a streaming manner: "_prisma_migrations"
  """
  _prisma_migrations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [_prisma_migrations_stream_cursor_input]!

    """filter the rows returned"""
    where: _prisma_migrations_bool_exp
  ): [_prisma_migrations!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}