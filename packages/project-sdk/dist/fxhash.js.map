{"version":3,"sources":["../../utils/src/base58.ts","../../utils/src/address.ts","../../utils/src/hash.ts","../../utils/src/math.ts","../../fxhash-params/src/utils.ts","../src/sdk/index.ts","../src/index.ts"],"sourcesContent":["/**\n * A string composed of all the base 58 encoding scheme characters, in the right\n * order.\n */\nexport const BASE58_CHARSET =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n","import { BASE58_CHARSET } from \"./base58\"\nimport { Blockchain } from \"./types/blockchain\"\n\nexport function mockEthereumAddress(): string {\n  const randomBytes = Array.from(\n    { length: 20 },\n    () => (Math.random() * 256) | 0\n  )\n  return `0x${Buffer.from(randomBytes).toString(\"hex\")}`\n}\n\nexport function mockTezosAddress() {\n  const randomSequence = Array.from(\n    { length: 33 },\n    () => BASE58_CHARSET[(Math.random() * BASE58_CHARSET.length) | 0]\n  ).join(\"\")\n  return `tz1${randomSequence}`\n}\n\nexport function mockBlockchainAddress(chain: Blockchain) {\n  if (chain === \"ETHEREUM\") return mockEthereumAddress()\n  return mockTezosAddress()\n}\n\nexport function isTezosAddressValid(address: string): boolean {\n  if (address.length !== 36) {\n    return false\n  }\n  for (let i = 0; i < address.length; i++) {\n    if (!BASE58_CHARSET.includes(address[i])) return false\n  }\n  return true\n}\n\nexport function isEthereumAddressValid(address: string): boolean {\n  return /^(0x)?[0-9a-fA-F]{40}$/.test(address)\n}\n\nexport function getBlockchainFromAddress(address: string): Blockchain {\n  if (isEthereumAddressValid(address)) return \"ETHEREUM\"\n  if (isTezosAddressValid(address)) return \"TEZOS\"\n  throw new Error(\n    \"The provided address is not a valid tezos or ethereum address\"\n  )\n}\n","import { BASE58_CHARSET } from \"./base58\"\nimport { Blockchain } from \"./types/blockchain\"\n\nexport function mockTezosTransactionHash(): string {\n  const randomSequence = Array.from(\n    { length: 49 },\n    () => BASE58_CHARSET[(Math.random() * BASE58_CHARSET.length) | 0]\n  ).join(\"\")\n  return `oo${randomSequence}`\n}\n\nexport function mockEthereumTransactionHash(): string {\n  const randomBytes = Array.from(\n    { length: 32 },\n    () => (Math.random() * 256) | 0\n  )\n  return `0x${Buffer.from(randomBytes).toString(\"hex\")}`\n}\n\nexport function mockTransactionHash(chain: Blockchain): string {\n  if (chain === \"ETHEREUM\") return mockEthereumTransactionHash()\n  return mockTezosTransactionHash()\n}\n\nexport function isEthereumTransactionHashValid(hash: string): boolean {\n  return /^(0x)?([A-Fa-f0-9]{64})$/.test(hash)\n}\n\nexport function isTezosTransactionHashValid(hash: string): boolean {\n  if (hash.length !== 51) {\n    return false\n  }\n  if (!hash.startsWith(\"oo\") && !hash.startsWith(\"op\")) {\n    return false\n  }\n  for (let i = 2; i < hash.length; i++) {\n    if (!BASE58_CHARSET.includes(hash[i])) return false\n  }\n  return true\n}\n\nexport function getBlockchainFromTransactionHash(hash: string): Blockchain {\n  if (isEthereumTransactionHashValid(hash)) return \"ETHEREUM\"\n  if (isTezosTransactionHashValid(hash)) return \"TEZOS\"\n  throw new Error(\n    \"The provided value is not a valid tezos or ethereum transaction hash\"\n  )\n}\n","import { isEthereumAddressValid, isTezosAddressValid } from \"./address\"\nimport { BASE58_CHARSET } from \"./base58\"\nimport {\n  isEthereumTransactionHashValid,\n  isTezosTransactionHashValid,\n} from \"./hash\"\nimport { ResettableRandFunction } from \"./types/math\"\n\nexport function getRandomHash(n: number): string {\n  return Array(n)\n    .fill(0)\n    .map(function (_) {\n      return BASE58_CHARSET[(Math.random() * BASE58_CHARSET.length) | 0]\n    })\n    .join(\"\")\n}\n\nfunction b58dec(str: string): number {\n  return [...str].reduce(function (p: number, c: string): number {\n    return (p * BASE58_CHARSET.length + BASE58_CHARSET.indexOf(c)) | 0\n  }, 0)\n}\n\nfunction sfc32(seed: number[]): () => number {\n  let a = seed[0] | 0\n  let b = seed[1] | 0\n  let c = seed[2] | 0\n  let d = seed[3] | 0\n  return function () {\n    a |= 0\n    b |= 0\n    c |= 0\n    d |= 0\n    const t = (((a + b) | 0) + d) | 0\n    d = (d + 1) | 0\n    a = b ^ (b >>> 9)\n    b = (c + (c << 3)) | 0\n    c = (c << 21) | (c >>> 11)\n    c = (c + t) | 0\n    return (t >>> 0) / 4294967296\n  }\n}\n\nfunction matcher(\n  str: string,\n  start: number,\n  decoder: (s: string) => number = b58dec\n): number[] {\n  return str\n    .slice(start)\n    .match(new RegExp(\".{\" + ((str.length - start) >> 2) + \"}\", \"g\"))\n    .map(decoder)\n}\n\nfunction getSeedFromHash(hash: string): number[] {\n  if (isEthereumTransactionHashValid(hash) || isEthereumAddressValid(hash)) {\n    return matcher(hash, 2, s => parseInt(s, 16) | 0)\n  } else if (isTezosAddressValid(hash)) {\n    return matcher(hash, 3)\n  } else {\n    return matcher(hash, 2)\n  }\n}\n\nexport function createFxRandom(hash: string): ResettableRandFunction {\n  const seed = getSeedFromHash(hash)\n  return sfc32(seed)\n}\n","import {\n  hexString,\n  FxParamDefinition,\n  FxParamProcessor,\n  FxParamProcessors,\n  FxParamTypeMap,\n  FxParamType,\n  FxParamsData,\n  FxParamValue,\n  FxParamTranformType,\n  FxParamTransformationTypeMap,\n  FxParamProcessorTransformer,\n} from \"./types\"\n\nexport function rgbaToHex(r: number, g: number, b: number, a: number): string {\n  const outParts = [\n    r.toString(16),\n    g.toString(16),\n    b.toString(16),\n    Math.round(a * 255)\n      .toString(16)\n      .substring(0, 2),\n  ]\n\n  // Pad single-digit output values\n  outParts.forEach(function (part, i) {\n    if (part.length === 1) {\n      outParts[i] = \"0\" + part\n    }\n  })\n\n  return \"#\" + outParts.join(\"\")\n}\n\nfunction completeHexColor(hexCode: hexString | string): string {\n  let hex = hexCode.replace(\"#\", \"\")\n  if (hex.length === 6) {\n    hex = `${hex}ff`\n  }\n  if (hex.length === 3) {\n    hex = `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}ff`\n  }\n  return hex\n}\n\nexport function hexToRgba(hexCode: hexString) {\n  const hex = completeHexColor(hexCode)\n\n  const r = parseInt(hex.substring(0, 2), 16)\n  const g = parseInt(hex.substring(2, 4), 16)\n  const b = parseInt(hex.substring(4, 6), 16)\n  const a =\n    Math.round(\n      (parseInt(hex.substring(6, 8), 16) / 255 + Number.EPSILON) * 100\n    ) / 100\n\n  return { r, g, b, a }\n}\n\nconst stringToHex = function (s: string) {\n  let rtn = \"\"\n  for (let i = 0; i < s.length; i++) {\n    rtn += s.charCodeAt(i).toString(16).padStart(4, \"0\")\n  }\n  return rtn\n}\nconst hexToString = function (h: string) {\n  const hx = h.match(/.{1,4}/g) || []\n  let rtn = \"\"\n  for (let i = 0; i < hx.length; i++) {\n    const int = parseInt(hx[i], 16)\n    if (int === 0) break\n    rtn += String.fromCharCode(int)\n  }\n  return rtn\n}\n\nexport const MIN_SAFE_INT64 = BigInt(\"-9223372036854775808\")\nexport const MAX_SAFE_INT64 = BigInt(\"9223372036854775807\")\n\nexport const ParameterProcessors: FxParamProcessors = {\n  number: {\n    serialize: input => {\n      const view = new DataView(new ArrayBuffer(8))\n      view.setFloat64(0, input)\n      return view.getBigUint64(0).toString(16).padStart(16, \"0\")\n    },\n    deserialize: input => {\n      const view = new DataView(new ArrayBuffer(8))\n      for (let i = 0; i < 8; i++) {\n        view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))\n      }\n      return view.getFloat64(0)\n    },\n    bytesLength: () => 8,\n    constrain: (value, definition) => {\n      let min = Number.MIN_SAFE_INTEGER\n      if (typeof definition.options?.min !== \"undefined\")\n        min = Number(definition.options.min)\n      let max = Number.MAX_SAFE_INTEGER\n      if (typeof definition.options?.max !== \"undefined\")\n        max = Number(definition.options.max)\n      max = Math.min(max, Number.MAX_SAFE_INTEGER)\n      min = Math.max(min, Number.MIN_SAFE_INTEGER)\n      const v = Math.min(Math.max(value, min), max)\n      if (definition?.options?.step) {\n        const t = 1.0 / definition?.options?.step\n        return Math.round(v * t) / t\n      }\n      return v\n    },\n    random: definition => {\n      let min = Number.MIN_SAFE_INTEGER\n      if (typeof definition.options?.min !== \"undefined\")\n        min = Number(definition.options.min)\n      let max = Number.MAX_SAFE_INTEGER\n      if (typeof definition.options?.max !== \"undefined\")\n        max = Number(definition.options.max)\n      max = Math.min(max, Number.MAX_SAFE_INTEGER)\n      min = Math.max(min, Number.MIN_SAFE_INTEGER)\n      const v = Math.random() * (max - min) + min\n      if (definition?.options?.step) {\n        const t = 1.0 / definition?.options?.step\n        return Math.round(v * t) / t\n      }\n      return v\n    },\n  },\n  bigint: {\n    serialize: (input: any) => {\n      const view = new DataView(new ArrayBuffer(8))\n      view.setBigInt64(0, BigInt(input))\n      return view.getBigUint64(0).toString(16).padStart(16, \"0\")\n    },\n    deserialize: (input: any) => {\n      const view = new DataView(new ArrayBuffer(8))\n      for (let i = 0; i < 8; i++) {\n        view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))\n      }\n      return view.getBigInt64(0)\n    },\n    bytesLength: () => 8,\n    random: (definition) => {\n      let min = MIN_SAFE_INT64\n      let max = MAX_SAFE_INT64\n      if (typeof definition.options?.min !== \"undefined\")\n        min = BigInt(definition.options.min)\n      if (typeof definition.options?.max !== \"undefined\")\n        max = BigInt(definition.options.max)\n      const range = max - min\n      const bits = range.toString(2).length\n      let random\n      do {\n        random = BigInt(\n          \"0b\" +\n            Array.from(\n              crypto.getRandomValues(new Uint8Array(Math.ceil(bits / 8)))\n            )\n              .map((b) => b.toString(2).padStart(8, \"0\"))\n              .join(\"\")\n        )\n      } while (random > range)\n      return random + min\n    },\n  },\n  boolean: {\n    serialize: (input) => {\n      return typeof input === \"boolean\"\n        ? input\n          ? \"01\"\n          : \"00\"\n        : typeof input === \"string\"\n        ? input === \"true\"\n          ? \"01\"\n          : \"00\"\n        : \"00\"\n    },\n    deserialize: (input) => {\n      return input === \"00\" ? false : true\n    },\n    bytesLength: () => 1,\n    random: () => Math.random() < 0.5,\n  },\n\n  color: {\n    serialize: (input: string) => {\n      return completeHexColor(input)\n    },\n\n    deserialize: (input): hexString => {\n      return input as hexString\n    },\n    bytesLength: () => 4,\n    transform: (input: string) => {\n      const color = completeHexColor(input)\n      const r = parseInt(color.slice(0, 2), 16)\n      const g = parseInt(color.slice(2, 4), 16)\n      const b = parseInt(color.slice(4, 6), 16)\n      const a = parseInt(color.slice(6, 8), 16)\n      return {\n        hex: {\n          rgb: \"#\" + input.slice(0, 6),\n          rgba: \"#\" + input,\n        },\n        obj: {\n          rgb: { r, g, b },\n          rgba: { r, g, b, a },\n        },\n        arr: {\n          rgb: [r, g, b],\n          rgba: [r, g, b, a],\n        },\n      }\n    },\n    constrain: (value) => {\n      const hex = value.replace(\"#\", \"\")\n      return hex.slice(0, 8).padEnd(8, \"f\")\n    },\n    random: () =>\n      `${[...Array(8)]\n        .map(() => Math.floor(Math.random() * 16).toString(16))\n        .join(\"\")}`,\n  },\n\n  string: {\n    serialize: (input, def) => {\n      if (!def.version) {\n        let hex = stringToHex(input.substring(0, 64))\n        hex = hex.padEnd(64 * 4, \"0\")\n        return hex\n      }\n      let max = 64\n      if (typeof def.options?.maxLength !== \"undefined\")\n        max = Number(def.options.maxLength)\n      let hex = stringToHex(input.substring(0, max))\n      hex = hex.padEnd(max * 4, \"0\")\n      return hex\n    },\n    deserialize: (input) => {\n      return hexToString(input)\n    },\n\n    bytesLength: (def) => {\n      if (!def.version) {\n        return 64 * 2\n      }\n      if (typeof def.options?.maxLength !== \"undefined\")\n        return Number(def.options.maxLength) * 2\n      return 64 * 2\n    },\n    random: (definition) => {\n      let min = 0\n      if (typeof definition.options?.minLength !== \"undefined\")\n        min = definition.options.minLength\n      let max = 64\n      if (typeof definition.options?.maxLength !== \"undefined\")\n        max = definition.options.maxLength\n      const length = Math.round(Math.random() * (max - min) + min)\n      return [...Array(length)]\n        .map((i) => (~~(Math.random() * 36)).toString(36))\n        .join(\"\")\n    },\n    constrain: (value, definition) => {\n      let min = 0\n      if (typeof definition.options?.minLength !== \"undefined\")\n        min = definition.options.minLength\n      let max = 64\n      if (typeof definition.options?.maxLength !== \"undefined\")\n        max = definition.options.maxLength\n      const v = value.slice(0, max)\n      if (v.length < min) {\n        return v.padEnd(min)\n      }\n      return v\n    },\n  },\n\n  bytes: {\n    serialize: (input, def) => {\n      return Array.from(input)\n        .map((i) => i.toString(16).padStart(2, \"0\"))\n        .join(\"\")\n    },\n    deserialize: (input, def) => {\n      const len = input.length / 2\n      const uint8 = new Uint8Array(len)\n      let idx\n      for (let i = 0; i < len; i++) {\n        idx = i * 2\n        uint8[i] = parseInt(`${input[idx]}${input[idx + 1]}`, 16)\n      }\n      return uint8\n    },\n    bytesLength: (def) => def.options.length,\n    random: (def) => {\n      const len = def.options?.length || 0\n      const uint8 = new Uint8Array(len)\n      for (let i = 0; i < len; i++) {\n        uint8[i] = (Math.random() * 255) | 0\n      }\n      return uint8\n    },\n  },\n\n  select: {\n    serialize: (input, def) => {\n      // find the index of the input in the array of options\n      return Math.min(255, def.options?.options?.indexOf(input) || 0)\n        .toString(16)\n        .padStart(2, \"0\")\n    },\n\n    deserialize: (input, def) => {\n      // get the index, which is the input\n      const idx = parseInt(input, 16)\n      return def.options?.options?.[idx] || def.options?.options?.[0] || \"\"\n    },\n\n    bytesLength: () => 1, // index between 0 and 255\n    constrain: (value, definition) => {\n      if (definition.options.options.includes(value)) {\n        return value\n      }\n      return definition.options.options[0]\n    },\n    random: (definition) => {\n      const index = Math.round(\n        Math.random() * (definition.options.options.length - 1) + 0\n      )\n      return definition?.options?.options[index]\n    },\n  },\n}\n\n// params are injected into the piece using the binary representation of the\n// numbers, to keep precision\nexport function serializeParams(\n  params: any,\n  definition: FxParamDefinition<any>[]\n) {\n  // a single hex string will be used for all the params\n  let bytes = \"\"\n  if (!definition) return bytes\n  // loop through each parameter from the definition to find the associated\n  // parameter as set on the UI\n  for (const def of definition) {\n    const { id, type } = def\n    const processor = ParameterProcessors[\n      type as FxParamType\n    ] as FxParamProcessor<any>\n    // if the param is definined in the object\n\n    const v = params[id] as FxParamTypeMap[]\n    const val =\n      typeof v !== \"undefined\"\n        ? v\n        : typeof def.default !== \"undefined\"\n        ? def.default\n        : processor.random(def)\n    const serialized = processor.serialize(val, def)\n    bytes += serialized\n  }\n\n  return bytes\n}\n\n// takes an array of bytes, in hexadecimal format, and a parametric space\n// definition and outputs an array of parameters, mapping the definition and\n// validating input based on the definition constraints\nexport function deserializeParams(\n  bytes: string,\n  definition: FxParamDefinition<FxParamType>[],\n  options: { withTransform?: boolean, transformType?: FxParamTranformType }\n) {\n  const params: Record<string, FxParamValue<FxParamType> | FxParamTransformationTypeMap[FxParamType]> = {}\n  for (const def of definition) {\n    const processor = ParameterProcessors[\n      def.type as FxParamType\n    ] as FxParamProcessor<FxParamType>\n    const transformer = options.withTransform && processor[options.transformType || \"transform\"] as FxParamProcessorTransformer<FxParamType>\n    if (!bytes) {\n      let v\n      if (typeof def.default === \"undefined\") v = processor.random(def)\n      else v = def.default\n      params[def.id] = transformer ? transformer(v, def) : v\n      continue\n    }\n    // extract the length from the bytes & shift the initial bytes string\n    const bytesLen = processor.bytesLength(def)\n    const valueBytes = bytes.substring(0, bytesLen * 2)\n    bytes = bytes.substring(bytesLen * 2)\n    // deserialize the bytes into the params\n    const val = processor.deserialize(valueBytes, def) as FxParamValue<FxParamType>\n    params[def.id] = transformer ? transformer(val, def) : val\n  }\n  return params\n}\n\n\n// Consolidates parameters from both a params object provided by the token\n// and the dat object of params, which is stored by the controls component.\nexport function consolidateParams(params: any, data: any) {\n  if (!params) return []\n\n  const rtn = [...params]\n\n  for (const p in rtn) {\n    const definition = rtn[p]\n    const { id, type, default: def } = definition\n    if (data && data.hasOwnProperty(id)) {\n      rtn[p].value = data[id]\n    } else {\n      const processor = ParameterProcessors[\n        type as FxParamType\n      ] as FxParamProcessor<any>\n      let v\n      if (typeof def === \"undefined\") v = processor.random(definition)\n      else v = def\n      rtn[p].value = processor.transform?.(v) || v\n    }\n  }\n\n  return rtn\n}\n\nexport function getRandomParamValues(\n  params: FxParamDefinition<FxParamType>[],\n  options?: { noTransform: boolean }\n): any {\n  return params.reduce((acc, definition) => {\n    const processor = ParameterProcessors[\n      definition.type as FxParamType\n    ] as FxParamProcessor<FxParamType>\n    const v = processor.random(definition) as FxParamType\n    acc[definition.id] = options?.noTransform\n      ? v\n      : processor.transform?.(v) || v\n    return acc\n  }, {} as Record<string, any>)\n}\n\nexport function sumBytesParams(\n  definitions: FxParamDefinition<FxParamType>[]\n): number {\n  return (\n    definitions?.reduce(\n      (acc, def) =>\n        acc +\n        (\n          ParameterProcessors[\n            def.type as FxParamType\n          ] as FxParamProcessor<FxParamType>\n        ).bytesLength(def),\n      0\n    ) || 0\n  )\n}\n\nexport function stringifyParamsData(data: FxParamsData) {\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === \"bigint\") return value.toString()\n    return value\n  })\n}\n\nexport function jsonStringifyBigint(data: any): string {\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === \"bigint\") return value.toString()\n    return value\n  })\n}\n\n\nexport const processParam = (paramId: string, value: FxParamValue<FxParamType>, definitions: FxParamDefinition<FxParamType>[], transformType: FxParamTranformType): FxParamValue<FxParamType> | FxParamTransformationTypeMap[FxParamType] => {\n    const definition = definitions.find(d => d.id === paramId)\n    const processor = ParameterProcessors[definition.type]\n    const transformer = (processor[transformType] as FxParamProcessorTransformer<FxParamType>)\n    return transformer?.(value, definition) || value\n  }\n\nexport const processParams = (values: FxParamsData, definitions: FxParamDefinition<FxParamType>[], transformType: FxParamTranformType) => {\n    const paramValues = {}\n    for (const definition of definitions) {\n      const processor = ParameterProcessors[definition.type]\n      const value = values[definition.id]\n      // deserialize the bytes into the params\n      const transformer = (processor[transformType] as FxParamProcessorTransformer<FxParamType>)\n      paramValues[definition.id] = transformer?.(value, definition) || value\n\n    }\n    return paramValues\n  }\n\n","import { FxHashApi, FxHashExecutionContext } from \"../types\"\nimport {\n  createFxRandom,\n  mockTezosAddress,\n  mockTezosTransactionHash,\n} from \"@fxhash/utils\"\nimport {\n  serializeParams,\n  processParams,\n  processParam,\n  deserializeParams,\n  ParameterProcessors,\n} from \"@fxhash/params/utils\"\n\nexport function createFxhashSdk(window, options): FxHashApi {\n  const { parent } = window\n\n  const search = new URLSearchParams(window.location.search)\n  // make fxrandstring from hash\n  const fxhash = search.get(\"fxhash\") || mockTezosTransactionHash()\n  let fxrand = createFxRandom(fxhash)\n  // make fxrandminter from minter address\n  const fxminter = search.get(\"fxminter\") || mockTezosAddress()\n  let fxrandminter = createFxRandom(fxminter)\n  // true if preview mode active, false otherwise\n  // you can append preview=1 to the URL to simulate preview active\n  const isFxpreview = search.get(\"preview\") === \"1\"\n  // call this method to trigger the preview\n  function fxpreview() {\n    window.dispatchEvent(new Event(\"fxhash-preview\"))\n    setTimeout(() => fxpreview(), 500)\n  }\n  // get the byte params from the URL\n  const searchParams = window.location.hash\n  const initialInputBytes = searchParams?.replace(\"#0x\", \"\")\n\n  const $fx = {\n    _version: \"4.0.0\",\n    _processors: ParameterProcessors,\n    // where params def & features will be stored\n    _params: undefined,\n    _features: undefined,\n    // where the parameter values are stored\n    _paramValues: {},\n    _listeners: {},\n    _receiveUpdateParams: async function (newRawValues, onDefault) {\n      const handlers = await this.propagateEvent(\"params:update\", newRawValues)\n      handlers.forEach(([optInDefault, onDone]) => {\n        if (!(typeof optInDefault == \"boolean\" && !optInDefault)) {\n          this._updateParams(newRawValues)\n          onDefault?.()\n        }\n        onDone?.(optInDefault, newRawValues)\n      })\n      if (handlers.length === 0) {\n        this._updateParams(newRawValues)\n        onDefault?.()\n      }\n    },\n    _updateParams: function (newRawValues) {\n      const constrained = processParams(\n        { ...this._rawValues, ...newRawValues },\n        this._params,\n        \"constrain\"\n      )\n      Object.keys(constrained).forEach(paramId => {\n        this._rawValues[paramId] = constrained[paramId]\n      })\n      this._paramValues = processParams(\n        this._rawValues,\n        this._params,\n        \"transform\"\n      )\n      this._updateInputBytes()\n    },\n    _updateInputBytes: function () {\n      const bytes = serializeParams(this._rawValues, this._params)\n      this.inputBytes = bytes\n    },\n    _emitParams: function (newRawValues) {\n      const constrainedValues = Object.keys(newRawValues).reduce(\n        (acc, paramId) => {\n          acc[paramId] = processParam(\n            paramId,\n            newRawValues[paramId],\n            this._params,\n            \"constrain\"\n          )\n          return acc\n        },\n        {}\n      )\n      this._receiveUpdateParams(constrainedValues, () => {\n        parent.postMessage(\n          {\n            id: \"fxhash_emit:params:update\",\n            data: {\n              params: constrainedValues,\n            },\n          },\n          \"*\"\n        )\n      })\n    },\n    hash: fxhash,\n    rand: fxrand,\n    minter: fxminter,\n    randminter: fxrandminter,\n    iteration: Number(search.get(\"fxiteration\")) || 1,\n    context:\n      (search.get(\"fxcontext\") as FxHashExecutionContext) || \"standalone\",\n    preview: fxpreview,\n    isPreview: isFxpreview,\n    params: function (definition) {\n      this._params = definition.map(def => ({ ...def, version: this._version }))\n      this._rawValues = deserializeParams(initialInputBytes, this._params, {\n        withTransform: true,\n        transformType: \"constrain\",\n      })\n      this._paramValues = processParams(\n        this._rawValues,\n        this._params,\n        \"transform\"\n      )\n      this._updateInputBytes()\n    },\n    features: function (features) {\n      this._features = features\n    },\n    getFeature: function (id) {\n      return this._features[id]\n    },\n    getFeatures: function () {\n      return this._features\n    },\n    getParam: function (id) {\n      return this._paramValues[id]\n    },\n    getParams: function () {\n      return this._paramValues\n    },\n    getRawParam: function (id) {\n      return this._rawValues[id]\n    },\n    getRawParams: function () {\n      return this._rawValues\n    },\n    getRandomParam: function (id) {\n      const definition = this._params.find(d => d.id === id)\n      const processor = ParameterProcessors[definition.type]\n      return processor.random(definition)\n    },\n    getDefinitions: function () {\n      return this._params\n    },\n    stringifyParams: function (params) {\n      return JSON.stringify(\n        params || this._rawValues,\n        (key, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value\n        },\n        2\n      )\n    },\n    on: function (name, callback, onDone) {\n      if (!this._listeners[name]) {\n        this._listeners[name] = []\n      }\n      this._listeners[name].push([callback, onDone])\n      return () => {\n        const index = this._listeners[name].findIndex(([c]) => c === callback)\n        if (index > -1) {\n          this._listeners[name].splice(index, 1)\n        }\n      }\n    },\n    propagateEvent: async function (name, data) {\n      const results = []\n      if (this._listeners?.[name]) {\n        for (const [callback, onDone] of this._listeners[name]) {\n          const result = callback(data)\n          results.push([\n            result instanceof Promise ? await result : result,\n            onDone,\n          ])\n        }\n      }\n      return results\n    },\n    emit: function (id, data) {\n      switch (id) {\n        case \"params:update\":\n          this._emitParams(data)\n          break\n        default:\n          console.log(\"$fx.emit called with unknown id:\", id)\n          break\n      }\n    },\n  }\n  const resetFxRand: () => void = () => {\n    fxrand = createFxRandom(fxhash)\n    $fx.rand = fxrand\n    fxrand.reset = resetFxRand\n  }\n  fxrand.reset = resetFxRand\n  const resetFxRandMinter: () => void = () => {\n    fxrandminter = createFxRandom(fxminter)\n    $fx.randminter = fxrandminter\n    fxrandminter.reset = resetFxRandMinter\n  }\n  fxrandminter.reset = resetFxRandMinter\n\n  window.addEventListener(\"message\", event => {\n    if (event.data === \"fxhash_getInfo\") {\n      parent.postMessage(\n        {\n          id: \"fxhash_getInfo\",\n          data: {\n            version: window.$fx._version,\n            hash: window.$fx.hash,\n            iteration: window.$fx.iteration,\n            features: window.$fx.getFeatures(),\n            params: {\n              definitions: window.$fx.getDefinitions(),\n              values: window.$fx.getRawParams(),\n            },\n            minter: window.$fx.minter,\n          },\n        },\n        \"*\"\n      )\n    }\n    if (event.data?.id === \"fxhash_params:update\") {\n      const { params } = event.data.data\n      if (params) window.$fx._receiveUpdateParams(params)\n    }\n  })\n  return $fx\n}\n","import { createFxhashSdk } from \"./sdk/index\"\n\nwindow.$fx = createFxhashSdk(window, {})\n\nexport * from \"./types\"\n"],"mappings":"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","names":["BASE58_CHARSET","mockTezosAddress","BASE58_CHARSET","isTezosAddressValid","address","i","BASE58_CHARSET","isEthereumAddressValid","mockTezosTransactionHash","BASE58_CHARSET","isEthereumTransactionHashValid","hash","b58dec","str","p","c","BASE58_CHARSET","sfc32","seed","a","b","d","t","matcher","start","decoder","getSeedFromHash","hash","isEthereumTransactionHashValid","isEthereumAddressValid","s","isTezosAddressValid","createFxRandom","completeHexColor","hexCode","hex","stringToHex","s","rtn","i","hexToString","h","hx","int","MIN_SAFE_INT64","MAX_SAFE_INT64","ParameterProcessors","input","view","value","definition","min","max","v","t","range","bits","random","b","completeHexColor","color","r","g","def","hex","length","len","uint8","idx","index","serializeParams","params","bytes","id","type","processor","val","serialized","deserializeParams","options","transformer","bytesLen","valueBytes","processParam","paramId","value","definitions","transformType","definition","d","transformer","ParameterProcessors","processParams","values","paramValues","processor","createFxhashSdk","window","options","parent","search","fxhash","mockTezosTransactionHash","fxrand","createFxRandom","fxminter","mockTezosAddress","fxrandminter","isFxpreview","fxpreview","initialInputBytes","$fx","ParameterProcessors","newRawValues","onDefault","handlers","optInDefault","onDone","constrained","processParams","paramId","bytes","serializeParams","constrainedValues","acc","processParam","definition","def","deserializeParams","features","id","d","params","key","value","name","callback","index","c","data","results","result","resetFxRand","resetFxRandMinter","event","createFxhashSdk"]}